---
title: 你应该知道的cors相关
description: 你应该知道的cors相关
ctime: 2024-06-11
---
# 跨域
跨域 (Cross-Origin) 是指一个域上的文档或脚本尝试去请求另一个域上的资源。这里的“域”指的是互联网域名系统中的域，通常由协议（比如 HTTP 或 HTTPS）、域名和端口组成。跨域问题是由于出于安全考虑，Web 浏览器实施的同源策略（Same-Origin Policy）造成的。

同源策略是一个安全协议，它规定了一个源（origin）的文档或脚本在没有明确授权的情况下，不能与其他源的资源进行交互。源的完全限定名必须完全匹配，否则两个源即被视为不同源，包含三个部分：

协议（Protocol，例如，http:// 或 https://）
域名（Domain，例如，example.com）
端口号（Port，例如，:80、:443，如果省略了端口，浏览器使用协议的默认端口）
比如，以下两个URL：

http://example.com/page1
http://example.com:80/page2
尽管它们的域名相同，但如果第一个地址的协议默认端口不是80（例如，https而非http），它们仍会被执行同源策略的浏览器视为不同源。

当你尝试通过脚本，在使用example.com源的web页面上发起对another.com源资源的请求时（例如，通过XMLHttpRequest 或 Fetch API），你会因为同源策略而遇到跨域问题。这种跨域请求会被浏览器拦截，除非远端源表明自己愿意接受来自该源的请求。以下是业界内比较常用的解决跨域方案。


# CORS
跨域不一定会导致资源不可访问，浏览器主要通过CORS的相关字段来判断可访问性。
网关程序在响应头中设置cors相关字段即可，有很多字段提供精细化控制，最简单只需要设置Access-Control-Allow-Origin即可。 注意此时的网关程序指的是最后一次修改header的程序，如后端程序做了处理，但是网关程序（如nginx）进行复写，则会冲掉后端程序的cors设置。以下是一部分字段的解析。
Access-Control-Allow-Origin
服务器使用此响应头来表明哪些源（origin）被允许访问该资源。如果服务器返回此响应头，并将浏览器请求的源列为允许的源，则浏览器将继续处理响应。如果未包括此响应头，或者浏览器的源不在允许的列表中，浏览器将拦截并拒绝响应。

Access-Control-Allow-Credentials
当前端请求包含凭据如Cookies或HTTP认证信息时，此响应头需要设置为true。要使凭据与CORS请求一起工作，前端代码也必须在XHR/Fetch请求中设置withCredentials。

Access-Control-Allow-Methods
在预检请求（preflight request，通常是一个HTTP OPTIONS请求）的响应中，此响应头指示实际请求（非预检请求）所允许使用的HTTP方法，如GET、POST或DELETE等，从而控制跨域请求可以执行哪些动作。

Access-Control-Allow-Headers
同样在预检请求的响应中使用，此响应头告诉浏览器允许跨域请求包含哪些HTTP头部字段。


# JSONP
1. 跨域资源加载
        JSONP 利用了浏览器可以跨域加载特定类型资源的特性，例如 <script> 标签的 src 属性可以加载并执行不同域的 JavaScript 文件，这种加载不受同源策略的限制。

2. 使用业务请求的方式处理资源请求
        服务器对待收到的 GET 请求不仅仅是响应传统的静态资源，而是将其作为执行特定逻辑的业务请求，然后动态生成并返回执行脚本。这要求服务器能够识别请求，从 URL 参数中提取数据，执行业务逻辑，最后动态创建并返回可执行的 JavaScript 代码（在 JSONP 的情况下）或其他形式的响应。

3. 可以执行的响应
        之所以使用 <script> 标签而不是其他标签， 是因为js具备天然优势。代码自然执行，不需要额外去设置执行，获取数据方便。 
        试想以下使用css实现jsonp是否可行呢？ 答案是一定的，比如使用某种特殊的格式去约定，比如以下
*{ --user-data: '{name: "aaa"}'} 
然后使用js去获取这个css变量肯定是可行的，但是这样就引入了额外的复杂度，所以js一定是更好的选择。

# 代理服务器
通过在同一个源服务器部署或设置代理来转发请求到其他源，从而间接满足同源策略的约束，此种方式用得不多，复用性不好。
